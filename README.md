# UNET сегментация для обработки томографических изображений

Код в данном репозитории представляет обертку для https://github.com/milesial/Pytorch-UNet с
добавлением классических методов сегментаций (RandomWalker).

Для применения данного ПО необходимо ввести входные параметры в файле config.yaml, а затем запустить main.py.

## Параметры config.yaml

### Системные настройки:

- *device: "server" или "laptop"* - если "server", то будут использоваться настройки для сохранения различных визуализаций
внутри mask_worker.py. Если "laptop" - они не будут сохраняться, а будут моментально выводиться на экран;

### Тренировка:

ВНИМАНИЕ: перед тренировкой необходимо распаковать архив из изображений. Должны быть папки imgs и masks. Файлы в этих масках должны иметь одинаковое название, но могут иметь разные расширения (например 1.tif - 1.png).

- *train: False* или *False* - тренировать модель или нет. При запуске впервые, модель необходимо натренировать.
Скрипт автоматически создаст файл весов для модели и поместит его в корень данного каталога. 
При желании это также можно сделать самостоятельно вручную, назвав его по типу MODEL_<target_feature>.pth (что такое <target_feature> смотри ниже, по умолчанию target_feature: "butterfly", а значит название файла модели должно быть MODEL_butterfly.pth);

- *scale_img: от 0 до 1* - параметр скейлинга изображений перед запуском нейросети для ускорения. Как правило, но не всегда, 
scale_img ближе к 1 приводит к увеличению качества сегментации.

### Сегментация нейронкой:

- *predict: True или False* - нужно ли запустить процесс сегментации нейронкой;

- *start_predictions: "beginning" или int число* - можно указать номер томографического сечения с которого начать инференс.
Может пригодиться при сбое сервера или иных проблемах, когда часть изображений уже отсегментирована, а другая - еще нет;

- *sample_number: int* - айди образца в произвольной форме. Например,если на синхротроне было измеренно несколько образцов,
то каждый из них может иметь собственный номер. Этот номер можно учитывать в названии папки с отсегментированными изображениями,
которая создастся автоматически;

- *target_feature: str* - произволдьное описание объекта сегментации, например "бабочка", если идет сегментация бабочки спинного мозга.
Этот параметр можно учитывать в названии папки с отсегментированными изображениями, которая создастся автоматически;

- *input_tomo_images: path* - путь к папке где лежат реконструированные томо изображения, которые необходимо сегментировать;

- *mask_images: path* - путь к папке КУДА поместить маски выхода сегментации;

- *output_masked_images: path* - реконструированные томо изображения маскируются масками после сегметации и будут сохранены там,
куда укажет этот путь.

### Постпроцессинг:

- *cleaning: True или False* - было сделано специально для сегментации "бабочки" в мозгу. Если True, то заливает все "дырки" и удаляет артефактные "скопления";

- *apply_masks: True или False* - нужно ли отмаскировать исходные томо изображения масками, полученными после сегментации;

- *output_masked_images: path* - реконструированные томо изображения маскируются масками после сегметации (если apply_masks: True) и будут сохранены там, куда укажет этот путь.

### Классическая сегментация мелких деталей изображения. RandomWlaker:

- *segment_small_features: True или False* - запустить рандомволкер, если True;

- *RandomWalker_mask_folder: "neurons_binary_mask"* - куда сохранять бинарные маски выхода RandomWlaker;

- *z_ranges: [[0, 560], [550, 1_110], [1_100, 1_660], [1_650, 2120]]* - как декомпозировать вычисления по вертикали для оптимизации.
Запустить RandomWlaker на всем и сразу вред ли получится (памяти надо много), но лишь по нескольким томографическим слоям - возможно. По умолчанию - сначала обрабатываем томо сечения от 0 по 560, потом 550-1110 (немного с перекрытием) и т.д. до 2120.

- *apply_boundary_mask: True или False* - не дать RandomWlaker выходить за края отсегментированного нейронкой изображения;

- *separate_small_features: True или False* - разделить ли отсегментированные детали на крупные и малые;

- *threshold_cluster_size: 7000* - порог разделения (количество вокселей в 3д объеме) деталей на крупные и малые.
